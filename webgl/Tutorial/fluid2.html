<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8">
<title>Liquid Toy (WebGL2)</title>
<style>
  html, body { margin:0; height:100%; background:#000; overflow:hidden; }
  canvas { width:100%; height:100%; display:block; }
</style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script type="module">
const canvas = document.getElementById("glcanvas");
const gl = canvas.getContext("webgl2");
if (!gl) { alert("WebGL2 not supported"); throw new Error("WebGL2 not supported"); }

canvas.width = innerWidth;
canvas.height = innerHeight;

//===================
// Vertex shader
//===================
const vertexSource = `#version 300 es
precision highp float;
layout(location=0) in vec2 aPos;
out vec2 vUV;
void main(){
  vUV = (aPos + 1.0) * 0.5;
  gl_Position = vec4(aPos,0.0,1.0);
}`;

//===================
// Fragment shaders
//===================

// Buffer A (simulation)
const bufferASource = `#version 300 es
precision highp float;
out vec4 fragColor;
uniform vec3 iResolution;
uniform float iTime;
uniform float iTimeDelta;
uniform vec4 iMouse;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;

#define TEX(uv) texture(iChannel0, uv).r
#define TEX1(uv) texture(iChannel1, uv).r
#define trace(edge, thin) smoothstep(thin, .0, edge)
#define ss(a,b,t) smoothstep(a,b,t)

const float speed = .001;
const float scale = .01;
const float falloff = 3.;
const float fade = .8;
const float strength = 1.;
const float range = 5.;

vec3 fbm(vec3 p){
  vec3 result = vec3(0.0);
  float amplitude = 0.5;
  for(float i=0.0;i<3.0;i++){
    result += texture(iChannel0, p.xy/amplitude).xyz * amplitude;
    amplitude /= falloff;
  }
  return result;
}

void main(){
  vec2 fragCoord = gl_FragCoord.xy;
  vec2 uv = (fragCoord - iResolution.xy/2.0)/iResolution.y;
  vec2 aspect = vec2(iResolution.x/iResolution.y,1.0);
  vec3 spice = fbm(vec3(uv*scale,iTime*speed));
  float t = iTime*2.0;
  vec2 mouse = (iMouse.xy - iResolution.xy/2.0)/iResolution.y;
  if(iMouse.z>0.5) uv -= mouse;
  else uv -= vec2(cos(t),sin(t))*0.3;
  float paint = trace(length(uv),0.04);
  vec2 offset = vec2(0.0);
  uv = fragCoord/iResolution.xy;
  vec4 data = texture(iChannel1, uv);
  vec3 unit = vec3(range/472.0/aspect,0.0);
  vec3 normal = normalize(vec3(
      TEX1(uv - unit.xz)-TEX1(uv + unit.xz),
      TEX1(uv - unit.zy)-TEX1(uv + unit.zy),
      data.x*data.x)+0.001);
  offset -= normal.xy;
  spice.x *= 6.28*2.0;
  spice.x += iTime;
  offset += vec2(cos(spice.x),sin(spice.x));
  uv += strength * offset / aspect / 472.0;
  vec4 frame = texture(iChannel1, uv);
  paint = max(paint, frame.x - iTimeDelta * fade);
  fragColor = vec4(clamp(paint,0.0,1.0));
}`;

// Final image
const imageSource = `#version 300 es
precision highp float;
out vec4 fragColor;
uniform vec3 iResolution;
uniform float iTime;
uniform vec4 iMouse;
uniform sampler2D iChannel0;
uniform sampler2D iChannel1;

#define TEX(uv) texture(iChannel0, uv).r
#define ss(a,b,t) smoothstep(a,b,t)

void main(){
  vec2 fragCoord = gl_FragCoord.xy;
  vec2 uv = fragCoord/iResolution.xy;
  vec3 dither = texture(iChannel1, fragCoord/1024.0).rgb;
  vec4 data = texture(iChannel0, uv);
  float gray = data.x;
  float range = 3.0;
  vec2 aspect = vec2(iResolution.x/iResolution.y,1.0);
  vec3 unit = vec3(range/472.0/aspect,0.0);
  vec3 normal = normalize(vec3(
      TEX(uv+unit.xz)-TEX(uv-unit.xz),
      TEX(uv-unit.zy)-TEX(uv+unit.zy),
      gray*gray*gray));
  vec3 color = vec3(0.3)*(1.0-abs(dot(normal,vec3(0,0,1))));
  vec3 dir = normalize(vec3(0,1,2));
  float specular = pow(dot(normal,dir)*0.5+0.5,20.0);
  //color += vec3(0.5)*ss(0.2,1.0,specular);
  vec3 tint = 0.5+0.5*cos(vec3(1,2,3)*1.0+dot(normal,dir)*4.0-uv.y*3.0-3.0);
  //color += tint*smoothstep(0.15,0.0,gray);
  color -= dither.x*0.1;
  vec3 background = vec3(1.0);
  background *= smoothstep(1.5,-0.5,length(uv-0.5));
  color = mix(background,(vec3(1.,1.,1.)-clamp(color,0.0,1.0)) * vec3(1.,0.,1.),ss(0.01,0.1,gray));
  color += vec3(0.5)*ss(0.2,1.0,specular);
  if(iMouse.z>0.5 && iMouse.x/iResolution.x<0.1){
    if(uv.x<0.33) color=vec3(gray);
    else if(uv.x<0.66) color=normal*0.5+0.5;
    else color=tint;
  }
  fragColor=vec4(color,1.0);
  fragColor=vec4(normal,1.0);
}`;

//===================
// Helper functions
//===================
function compileShader(type, src){
  const s = gl.createShader(type);
  gl.shaderSource(s, src);
  gl.compileShader(s);
  if(!gl.getShaderParameter(s, gl.COMPILE_STATUS))
    throw new Error(gl.getShaderInfoLog(s));
  return s;
}
function makeProgram(vsSrc, fsSrc){
  const p = gl.createProgram();
  gl.attachShader(p, compileShader(gl.VERTEX_SHADER, vsSrc));
  gl.attachShader(p, compileShader(gl.FRAGMENT_SHADER, fsSrc));
  gl.linkProgram(p);
  if(!gl.getProgramParameter(p, gl.LINK_STATUS))
    throw new Error(gl.getProgramInfoLog(p));
  return p;
}

//===================
// Setup programs
//===================
const quad = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, quad);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1,-1, 1,-1, -1,1, 1,1
]), gl.STATIC_DRAW);

const progA = makeProgram(vertexSource, bufferASource);
const progFinal = makeProgram(vertexSource, imageSource);

// create pingpong FBOs
function createFBO(){
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,canvas.width,canvas.height,0,gl.RGBA,gl.UNSIGNED_BYTE,null);
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  return {tex, fb};
}
let fbo1 = createFBO();
let fbo2 = createFBO();

// simple noise texture
function makeNoise(size){
  const data = new Uint8Array(size*size*4);
  for(let i=0;i<data.length;i++) data[i]=Math.random()*255;
  const t = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D,t);
  gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,size,size,0,gl.RGBA,gl.UNSIGNED_BYTE,data);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
  return t;
}
const noiseTex = makeNoise(256);

let time = 0, last = performance.now(), mouse=[0,0,0,0];
canvas.onpointermove=e=>{mouse[0]=e.clientX; mouse[1]=canvas.height-e.clientY;};
canvas.onpointerdown=e=>{mouse[2]=1; mouse[3]=1;};
canvas.onpointerup=e=>{mouse[2]=0; mouse[3]=0;};

//===================
// Render loop
//===================
function render(){
  const now = performance.now();
  const dt = (now-last)/1000; last=now; time+=dt;

  // pass A
  gl.useProgram(progA);
  gl.bindFramebuffer(gl.FRAMEBUFFER,fbo2.fb);
  gl.viewport(0,0,canvas.width,canvas.height);
  const loc = gl.getAttribLocation(progA,"aPos");
  gl.bindBuffer(gl.ARRAY_BUFFER, quad);
  gl.enableVertexAttribArray(loc);
  gl.vertexAttribPointer(loc,2,gl.FLOAT,false,0,0);
  gl.uniform3f(gl.getUniformLocation(progA,"iResolution"),canvas.width,canvas.height,1);
  gl.uniform1f(gl.getUniformLocation(progA,"iTime"),time);
  gl.uniform1f(gl.getUniformLocation(progA,"iTimeDelta"),dt);
  gl.uniform4f(gl.getUniformLocation(progA,"iMouse"),...mouse);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, noiseTex);
  gl.uniform1i(gl.getUniformLocation(progA,"iChannel0"),0);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D, fbo1.tex);
  gl.uniform1i(gl.getUniformLocation(progA,"iChannel1"),1);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

  // final image
  gl.useProgram(progFinal);
  gl.bindFramebuffer(gl.FRAMEBUFFER,null);
  gl.viewport(0,0,canvas.width,canvas.height);
  const loc2 = gl.getAttribLocation(progFinal,"aPos");
  gl.bindBuffer(gl.ARRAY_BUFFER,quad);
  gl.enableVertexAttribArray(loc2);
  gl.vertexAttribPointer(loc2,2,gl.FLOAT,false,0,0);
  gl.uniform3f(gl.getUniformLocation(progFinal,"iResolution"),canvas.width,canvas.height,1);
  gl.uniform1f(gl.getUniformLocation(progFinal,"iTime"),time);
  gl.uniform4f(gl.getUniformLocation(progFinal,"iMouse"),...mouse);
  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D,fbo2.tex);
  gl.uniform1i(gl.getUniformLocation(progFinal,"iChannel0"),0);
  gl.activeTexture(gl.TEXTURE1);
  gl.bindTexture(gl.TEXTURE_2D,noiseTex);
  gl.uniform1i(gl.getUniformLocation(progFinal,"iChannel1"),1);
  gl.drawArrays(gl.TRIANGLE_STRIP,0,4);

  [fbo1,fbo2]=[fbo2,fbo1];
  requestAnimationFrame(render);
}
render();
</script>
</body>
</html>
