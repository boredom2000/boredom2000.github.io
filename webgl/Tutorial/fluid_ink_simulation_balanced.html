
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Balanced Glossy Fluid Ink Simulation</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let mouse = [0.5, 0.5];
canvas.addEventListener('mousemove', e => {
  mouse[0] = e.clientX / canvas.width;
  mouse[1] = 1.0 - e.clientY / canvas.height;
});

const vertexShaderSource = `
attribute vec2 a_position;
varying vec2 v_uv;
uniform float u_time;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  float zoom = 1.0 + 0.01 * sin(a_position.x * 2.0 + a_position.y * 2.0 + u_time * 0.033);
  gl_Position = vec4(a_position * zoom, 0.0, 1.0);
}`;

const fragmentShaderSource = `
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_texture;
uniform vec2 u_mouse;
uniform float u_time;

vec3 hsl2rgb(float h, float s, float l) {
  float c = (1.0 - abs(2.0 * l - 1.0)) * s;
  float x = c * (1.0 - abs(mod(h * 6.0, 2.0) - 1.0));
  float m = l - c / 2.0;
  vec3 rgb;
  if (h < 1.0/6.0) rgb = vec3(c, x, 0.0);
  else if (h < 2.0/6.0) rgb = vec3(x, c, 0.0);
  else if (h < 3.0/6.0) rgb = vec3(0.0, c, x);
  else if (h < 4.0/6.0) rgb = vec3(0.0, x, c);
  else if (h < 5.0/6.0) rgb = vec3(x, 0.0, c);
  else rgb = vec3(c, 0.0, x);
  return rgb + vec3(m);
}

void main() {
  vec2 uv = v_uv;
  float angle = sin(u_time * 0.1 + uv.x * 30.0) * 3.14;
  float radius = 0.002 + 0.004 * sin(u_time + uv.y * 20.0);
  vec2 offset = vec2(cos(angle), sin(angle)) * radius;
  uv += offset;

  vec4 color = texture2D(u_texture, uv);

  float dx = 1.0 / 800.0;
  float dy = 1.0 / 600.0;
  vec4 sum =
    texture2D(u_texture, uv + vec2(-dx, 0.0)) +
    texture2D(u_texture, uv + vec2(dx, 0.0)) +
    texture2D(u_texture, uv + vec2(0.0, -dy)) +
    texture2D(u_texture, uv + vec2(0.0, dy));
  color = mix(color, sum * 0.25, 0.05);

  float dist = distance(v_uv, u_mouse);
  float inkRadius = 0.10;
  if (dist < inkRadius) {
    float strength = smoothstep(inkRadius, 0.0, dist);
    float hue = mod(u_time * 0.1, 1.0);
    vec3 inkColor = hsl2rgb(hue, 1.0, 0.5);
    color.rgb = mix(color.rgb, inkColor, strength);
  }

  vec3 lightDir = normalize(vec3(-0.5, 0.5, 1.0));
  vec3 normal = normalize(vec3(uv.x - 0.5, uv.y - 0.5, 0.5));
  float light = dot(normal, lightDir);
  float gloss = pow(max(light, 0.0), 4.0);
  vec3 highlight = vec3(1.0) * gloss * 0.2;
  vec3 ambient = vec3(0.05, 0.05, 0.05);
  color.rgb = color.rgb * 0.85 + highlight + ambient;

  gl_FragColor = vec4(color.rgb, 1.0);
}`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  return shader;
}

function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  return program;
}

const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
const positionLocation = gl.getAttribLocation(program, 'a_position');
const timeLocation = gl.getUniformLocation(program, 'u_time');
const mouseLocation = gl.getUniformLocation(program, 'u_mouse');
const textureLocation = gl.getUniformLocation(program, 'u_texture');

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
  -1,  1,
   1, -1,
   1,  1,
]), gl.STATIC_DRAW);

function createTexture() {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0,
                gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return tex;
}

function createFramebuffer(tex) {
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  return fb;
}

const texA = createTexture();
const texB = createTexture();
const fbA = createFramebuffer(texA);
const fbB = createFramebuffer(texB);

let flip = true;

function render(time) {
  time *= 0.001;

  const readTex = flip ? texA : texB;
  const writeFb = flip ? fbB : fbA;

  gl.bindFramebuffer(gl.FRAMEBUFFER, writeFb);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, readTex);
  gl.uniform1i(textureLocation, 0);
  gl.uniform1f(timeLocation, time);
  gl.uniform2fv(mouseLocation, mouse);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, writeFb === fbB ? texB : texA);
  gl.uniform1i(textureLocation, 0);
  gl.uniform1f(timeLocation, time);
  gl.uniform2fv(mouseLocation, mouse);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  flip = !flip;
  requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body>
</html>
