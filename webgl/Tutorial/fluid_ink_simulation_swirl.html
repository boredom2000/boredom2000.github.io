
<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Swirling Ink Simulation</title>
  <style>
    html, body { margin: 0; overflow: hidden; height: 100%; }
    canvas { display: block; width: 100%; height: 100%; }
  </style>
</head>
<body>
<canvas id="glcanvas"></canvas>
<script>
const canvas = document.getElementById('glcanvas');
const gl = canvas.getContext('webgl');
canvas.width = window.innerWidth;
canvas.height = window.innerHeight;

let mouse = [0.5, 0.5];
canvas.addEventListener('mousemove', e => {
  mouse[0] = e.clientX / canvas.width;
  mouse[1] = 1.0 - e.clientY / canvas.height;
});

const vertexShaderSource = `
attribute vec2 a_position;
varying vec2 v_uv;
void main() {
  v_uv = a_position * 0.5 + 0.5;
  gl_Position = vec4(a_position, 0.0, 1.0);
}`;

const fragmentShaderSource = `
precision highp float;
varying vec2 v_uv;
uniform sampler2D u_texture;
uniform vec2 u_mouse;
uniform float u_time;

float random(vec2 st) {
  return fract(sin(dot(st.xy, vec2(12.9898,78.233))) * 43758.5453123);
}

void main() {
  vec2 uv = v_uv;
  vec2 swirl = vec2(sin(uv.y * 10.0 + u_time), cos(uv.x * 10.0 + u_time)) * 0.01;
  uv += swirl;

  vec4 color = texture2D(u_texture, uv);

  // Diffusion effect
  float dx = 1.0 / float(${canvas.width});
  float dy = 1.0 / float(${canvas.height});
  vec4 sum =
    texture2D(u_texture, uv + vec2(-dx, 0.0)) +
    texture2D(u_texture, uv + vec2(dx, 0.0)) +
    texture2D(u_texture, uv + vec2(0.0, -dy)) +
    texture2D(u_texture, uv + vec2(0.0, dy));
  color = mix(color, sum * 0.25, 0.05);

  // Add ink at mouse position with alternating color
  float dist = distance(v_uv, u_mouse);
  float radius = 0.05;
  if (dist < radius) {
    float strength = smoothstep(radius, 0.0, dist);
    float r = random(v_uv + u_time);
    vec3 inkColor = vec3(
      0.5 + 0.5 * sin(u_time * 3.0 + r * 6.28),
      0.5 + 0.5 * sin(u_time * 2.0 + r * 6.28 + 2.0),
      0.5 + 0.5 * sin(u_time * 4.0 + r * 6.28 + 4.0)
    );
    color.rgb += inkColor * strength * 0.2;
  }

  gl_FragColor = vec4(color.rgb, 1.0);
}`;

function createShader(gl, type, source) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error(gl.getShaderInfoLog(shader));
    gl.deleteShader(shader);
    return null;
  }
  return shader;
}

function createProgram(gl, vsSource, fsSource) {
  const vs = createShader(gl, gl.VERTEX_SHADER, vsSource);
  const fs = createShader(gl, gl.FRAGMENT_SHADER, fsSource);
  const program = gl.createProgram();
  gl.attachShader(program, vs);
  gl.attachShader(program, fs);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error(gl.getProgramInfoLog(program));
    return null;
  }
  return program;
}

const program = createProgram(gl, vertexShaderSource, fragmentShaderSource);
const positionLocation = gl.getAttribLocation(program, 'a_position');
const mouseLocation = gl.getUniformLocation(program, 'u_mouse');
const timeLocation = gl.getUniformLocation(program, 'u_time');
const textureLocation = gl.getUniformLocation(program, 'u_texture');

const positionBuffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([
  -1, -1,
   1, -1,
  -1,  1,
  -1,  1,
   1, -1,
   1,  1,
]), gl.STATIC_DRAW);

function createTexture() {
  const tex = gl.createTexture();
  gl.bindTexture(gl.TEXTURE_2D, tex);
  gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, canvas.width, canvas.height, 0,
                gl.RGBA, gl.UNSIGNED_BYTE, null);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
  return tex;
}

function createFramebuffer(tex) {
  const fb = gl.createFramebuffer();
  gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
  gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
  return fb;
}

const texA = createTexture();
const texB = createTexture();
const fbA = createFramebuffer(texA);
const fbB = createFramebuffer(texB);

let flip = true;

function render(time) {
  time *= 0.001;

  const readTex = flip ? texA : texB;
  const writeFb = flip ? fbB : fbA;

  gl.bindFramebuffer(gl.FRAMEBUFFER, writeFb);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, readTex);
  gl.uniform1i(textureLocation, 0);
  gl.uniform2fv(mouseLocation, mouse);
  gl.uniform1f(timeLocation, time);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  // draw to screen
  gl.bindFramebuffer(gl.FRAMEBUFFER, null);
  gl.viewport(0, 0, canvas.width, canvas.height);
  gl.useProgram(program);

  gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
  gl.enableVertexAttribArray(positionLocation);
  gl.vertexAttribPointer(positionLocation, 2, gl.FLOAT, false, 0, 0);

  gl.activeTexture(gl.TEXTURE0);
  gl.bindTexture(gl.TEXTURE_2D, writeFb === fbB ? texB : texA);
  gl.uniform1i(textureLocation, 0);
  gl.uniform2fv(mouseLocation, mouse);
  gl.uniform1f(timeLocation, time);

  gl.drawArrays(gl.TRIANGLES, 0, 6);

  flip = !flip;
  requestAnimationFrame(render);
}

requestAnimationFrame(render);
</script>
</body>
</html>
